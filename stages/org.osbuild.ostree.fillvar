#!/usr/bin/python3
"""
Pre-populate /var directory for a given stateroot.
"""


import contextlib
import os
import sys
import subprocess

import osbuild.api


SCHEMA_2 = """
"options": {
  "required": ["osname", "ref"],
  "properties": {
    "osname": {
      "description": "Name of the stateroot to be used in the deployment",
      "type": "string"
    },
    "ref": {
      "description": "OStree ref to create and use for deployment",
      "type": "string"
    }
  }
}
"""


def ostree(*args, _input=None, _stdout=None, **kwargs):
    args = list(args) + [f'--{k}={v}' for k, v in kwargs.items()]
    print("ostree " + " ".join(args), file=sys.stderr)

    if _stdout is None:
        _stdout = subprocess.PIPE

    r = subprocess.run(["ostree"] + args,
                       encoding="utf-8",
                       stdout=_stdout,
                       input=_input,
                       check=True)

    print(r.stdout)

    return r


class MountGuard(contextlib.AbstractContextManager):
    def __init__(self):
        self.mounts = []

    def mount(self, source, target, bind=True, ro=False, mode="0755"):
        options = []
        if bind:
            options += ["bind"]
        if ro:
            options += ["ro"]
        if mode:
            options += [mode]

        args = ["--make-private"]
        if options:
            args += ["-o", ",".join(options)]

        subprocess.run(["mount"] + args + [source, target], check=True)
        self.mounts += [{"source": source, "target": target}]

        subprocess.run(["mount"] + args + [source, target], check=True)

    def unmount(self):

        while self.mounts:
            mount = self.mounts.pop()  # FILO: get the last mount
            target = mount["target"]
            subprocess.run(["umount", "--lazy", target],
                           check=True)

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.unmount()


def populate_var(sysroot):
    # Like anaconda[1] and Fedora CoreOS dracut[2]
    # [1] pyanaconda/payload/rpmostreepayload.py
    # [2] ignition-ostree-populate-var.sh

    for target in ('lib', 'log'):
        os.makedirs(f"{sysroot}/var/{target}", exist_ok=True)

    for target in ('home', 'roothome', 'lib/rpm', 'opt', 'srv',
                   'usrlocal', 'mnt', 'media', 'spool', 'spool/mail'):

        if os.path.exists(f"{sysroot}/var/{target}"):
            continue

        res = subprocess.run(["systemd-tmpfiles", "--create", "--boot",
                              "--root=" + sysroot,
                              "--prefix=/var/" + target],
                             encoding="utf-8",
                             stdout=sys.stderr,
                             check=False)

        # According to systemd-tmpfiles(8), the return values are:
        #  0 → success
        # 65 → so some lines had to be ignored, but no other errors
        # 73 → configuration ok, but could not be created
        #  1 → other error
        if res.returncode not in [0, 65]:
            raise RuntimeError(f"Failed to provision /var/{target}")


def main(tree, options):

    osname = options["osname"]
    ref = options["ref"]
    repo = f"{tree}/ostree/repo"

    commit = ostree("rev-parse", ref, repo=repo).stdout.strip()

    # NB: if there are multiple commits, we deploy only
    # the latest one

    # this created a state root at `osname`
    stateroot = f"{tree}/ostree/deploy/{osname}"

    # now that we have a deployment, we do have a sysroot
    sysroot = f"{stateroot}/deploy/{commit}.0"

    with MountGuard() as mgr:
        mgr.mount(f"{stateroot}/var", f"{sysroot}/var")
        populate_var(sysroot)


if __name__ == '__main__':
    stage_args = osbuild.api.arguments()
    r = main(stage_args["tree"],
             stage_args["options"])
    sys.exit(r)
