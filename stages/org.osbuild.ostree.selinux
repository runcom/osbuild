#!/usr/bin/python3
"""
Fix SELinux labels for an OSTree deployment[1].

[1] https://ostree.readthedocs.io/en/latest/manual/deployment/
"""


import os
import sys
import subprocess

import osbuild.api
from osbuild.util import selinux


SCHEMA = """
"required": ["osname", "ref"],
"properties": {
  "osname": {
    "description": "Name of the stateroot to be used in the deployment",
    "type": "string"
  },
  "ref": {
    "description": "OStree ref to create and use for deployment",
    "type": "string"
  }
}
"""


def ostree(*args, _input=None, _stdout=None, **kwargs):
    args = list(args) + [f'--{k}={v}' for k, v in kwargs.items()]
    print("ostree " + " ".join(args), file=sys.stderr)

    if _stdout is None:
        _stdout = subprocess.PIPE

    r = subprocess.run(["ostree"] + args,
                       encoding="utf-8",
                       stdout=_stdout,
                       input=_input,
                       check=True)

    print(r.stdout)

    return r


def main(tree, options):

    osname = options["osname"]
    ref = options["ref"]
    repo = f"{tree}/ostree/repo"

    commit = ostree("rev-parse", ref, repo=repo).stdout.strip()

    # NB: if there are multiple commits, we deploy only
    # the latest one

    # this created a state root at `osname`
    stateroot = f"{tree}/ostree/deploy/{osname}"

    # now that we have a deployment, we do have a sysroot
    sysroot = f"{stateroot}/deploy/{commit}.0"

    # deploying a tree creates new files that need to be properly
    # labeled for SELinux. In theory, ostree will take care of
    # this by loading the SELinux config from the deployment and
    # then applying the labels; but it does so conditionally on
    # is_selinux_enabled(2), which in our container is FALSE
    # Therefore we have to do the same dance as ostree does, at
    # least for now, and manually re-label the affected paths
    se_policy = None

    for p in ["etc/selinux", "usr/etc/selinux"]:
        se_home = os.path.join(sysroot, p)
        cfgfile = os.path.join(se_home, "config")
        if not os.path.isfile(cfgfile):
            continue

        with open(cfgfile, 'r') as f:
            cfg = selinux.parse_config(f)
        se_policy = selinux.config_get_policy(cfg)

        if se_policy:
            break

    if not se_policy:
        raise ValueError("Could not find SELinux policy")

    spec = f"{se_home}/{se_policy}/contexts/files/file_contexts"
    # kernel, initramfs & BLS config snippets were
    # written to {tree}/boot
    selinux.setfiles(spec, tree, "/boot")
    # various config files will be created as a result
    # of the 3-way configuration merge, see ostree(3)
    selinux.setfiles(spec, sysroot, "/etc")
    # if we populated /var, we need to fix its labels
    selinux.setfiles(spec, stateroot, "/var")


if __name__ == '__main__':
    stage_args = osbuild.api.arguments()
    stage_res = main(stage_args["tree"],
                     stage_args["options"])
    sys.exit(stage_res)
